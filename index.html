<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>오프라인 러너 - Enhanced</title>
  <meta name="description" content="향상된 크롬 공룡 느낌의 러너 게임. 디테일한 그래픽, 파워업, 콤보 시스템 포함." />
  <style>
    :root{
      --bg:#eef1f5; --ink:#0f172a; --muted:#64748b; --line:#cbd5e1; --accent:#111827;
      --gold:#fbbf24; --purple:#8b5cf6; --green:#10b981;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; color:var(--ink); background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); display:grid; place-items:center}
    .wrap{ width:min(96vw,980px); padding:16px }
    .card{ background:linear-gradient(145deg, #ffffff, #f3f4f6); border:2px solid #e5e7eb; border-radius:20px; padding:16px; box-shadow:0 20px 40px rgba(0,0,0,.12), inset 0 1px 3px rgba(255,255,255,.5) }
    header{ display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap }
    h1{ font-size:20px; margin:0; background:linear-gradient(135deg, #667eea, #764ba2); -webkit-background-clip:text; -webkit-text-fill-color:transparent; font-weight:800 }
    .btns{ display:flex; gap:8px }
    button{ border:1px solid #e5e7eb; background:linear-gradient(145deg, #ffffff, #f9fafb); padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; transition:all .2s; box-shadow:0 2px 4px rgba(0,0,0,.05) }
    button:hover{ transform:translateY(-2px); box-shadow:0 4px 8px rgba(0,0,0,.1) }
    button:active{ transform:translateY(0) }
    canvas{ display:block; width:100%; height:auto; border:3px solid var(--accent); border-radius:16px; background:linear-gradient(to bottom, #87ceeb 0%, #98d8e8 50%, #ffeaa7 100%); box-shadow:inset 0 2px 8px rgba(0,0,0,.1) }
    .hint{ margin-top:12px; font-size:14px; color:var(--muted); text-align:center }
    .mobile-ctrls{ display:none; margin-top:12px; gap:10px }
    .mobile-ctrls button{ flex:1; padding:16px; font-size:18px; background:linear-gradient(145deg, #667eea, #764ba2); color:white; border:none }
    .stats{ display:flex; gap:16px; margin-top:12px; justify-content:center; flex-wrap:wrap }
    .stat{ background:linear-gradient(145deg, #f9fafb, #ffffff); padding:8px 16px; border-radius:12px; font-size:14px; font-weight:600; box-shadow:0 2px 4px rgba(0,0,0,.05) }
    .stat span{ color:var(--purple); font-weight:800 }
    @media (hover:none) and (pointer:coarse){ .mobile-ctrls{ display:flex } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1>🦖 오프라인 러너 Enhanced</h1>
        <div class="btns">
          <button id="startBtn" title="시작(S)">▶️ 시작</button>
          <button id="restartBtn" title="다시 시작(R)">🔄 다시</button>
          <button id="pauseBtn" title="일시정지(P)">⏸️ 일시정지</button>
        </div>
      </header>
      <canvas id="game" width="900" height="320" aria-label="향상된 오프라인 러너 게임"></canvas>
      <div class="mobile-ctrls">
        <button id="jumpBtn">🦘 점프</button>
        <button id="duckBtn">🐢 숙이기</button>
      </div>
      <div class="stats">
        <div class="stat">콤보: <span id="combo">0</span></div>
        <div class="stat">최고 콤보: <span id="maxCombo">0</span></div>
        <div class="stat">코인: <span id="coins">0</span></div>
      </div>
      <p class="hint">🎮 Space/↑ 점프 | ↓ 숙이기 | 더블점프 가능! | 코인과 파워업을 모으세요!</p>
    </div>
  </div>

  <script>
  ;(() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // 고해상도 스케일링
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function setupCanvas(){
      const w = canvas.width, h = canvas.height;
      canvas.width = w * DPR; canvas.height = h * DPR; ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    setupCanvas();

    // 월드
    const world = { w: canvas.width / DPR, h: canvas.height / DPR, groundY: 260, time: 0 };

    // 상태
    let running = false, paused = false, gameOver = false;
    let speed = 6.8;
    let score = 0, high = 0; 
    let combo = 0, maxCombo = 0, coins = 0, totalCoins = 0;
    let lastObstacleJumped = null;
    
    try{ 
      high = +localStorage.getItem('runnerHigh') || 0;
      totalCoins = +localStorage.getItem('runnerCoins') || 0;
    }catch{}

    // 파워업 상태
    let powerups = {
      invincible: 0,
      doubleJump: 0,
      magnet: 0,
      slowmo: 0
    };

    // 유틸
    const rand = (a,b)=>Math.random()*(b-a)+a;
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

    // 파티클 시스템
    const particles = [];
    class Particle {
      constructor(x, y, color, size = 3) {
        this.x = x; this.y = y;
        this.vx = rand(-3, 3); this.vy = rand(-5, -2);
        this.life = 1; this.color = color; this.size = size;
      }
      update(dt) {
        this.x += this.vx; this.y += this.vy;
        this.vy += 0.3; this.life -= 0.03;
        return this.life > 0;
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    function spawnParticles(x, y, color, count = 10) {
      for(let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color));
      }
    }

    // 향상된 배경
    const mountains = [
      { y: world.groundY-10, speed: .15, peaks: genPeaks(10, 50, 100), color: '#cbd5e1' },
      { y: world.groundY-5, speed: .25, peaks: genPeaks(12, 35, 70), color: '#e2e8f0' },
      { y: world.groundY-2, speed: .4, peaks: genPeaks(15, 20, 45), color: '#f1f5f9' }
    ];
    
    function genPeaks(n, hmin, hmax){
      const arr=[]; let x=0; 
      for(let i=0;i<n;i++){ 
        const w = rand(60,120); 
        const h = rand(hmin,hmax);
        arr.push({x, w, h, snowCap: h > hmax*0.7}); 
        x+=w; 
      } 
      return arr;
    }
    
    function drawMountains(){
      mountains.forEach((layer,i)=>{
        ctx.save(); 
        ctx.fillStyle = layer.color;
        ctx.translate(-((world.time*layer.speed)% (layer.peaks.reduce((s,p)=>s+p.w,0))),0);
        let ox=0;
        for(let r=0;r<2;r++){
          ox = 0;
          for(const p of layer.peaks){
            // 산 그리기
            ctx.beginPath();
            ctx.moveTo(ox+p.x, world.groundY);
            ctx.lineTo(ox+p.x+p.w*0.3, world.groundY-p.h*0.7);
            ctx.lineTo(ox+p.x+p.w/2, world.groundY-p.h);
            ctx.lineTo(ox+p.x+p.w*0.7, world.groundY-p.h*0.8);
            ctx.lineTo(ox+p.x+p.w, world.groundY);
            ctx.closePath(); 
            ctx.fill();
            
            // 눈 덮인 봉우리
            if(p.snowCap) {
              ctx.fillStyle = '#ffffff';
              ctx.beginPath();
              ctx.moveTo(ox+p.x+p.w*0.3, world.groundY-p.h*0.7);
              ctx.lineTo(ox+p.x+p.w/2, world.groundY-p.h);
              ctx.lineTo(ox+p.x+p.w*0.7, world.groundY-p.h*0.8);
              ctx.closePath();
              ctx.fill();
              ctx.fillStyle = layer.color;
            }
          }
          ctx.translate(layer.peaks.reduce((s,p)=>s+p.w,0),0);
        }
        ctx.restore();
      });
    }

    // 구름 시스템
    const clouds=[];
    function spawnCloud(){ 
      clouds.push({
        x: world.w + 20, 
        y: rand(20, 100), 
        s: rand(0.5, 1.5),
        type: Math.random() > 0.7 ? 'fluffy' : 'normal'
      });
    }
    
    function updateClouds(dt){ 
      for(const c of clouds){ c.x -= speed * 0.2 * c.s; } 
      while(clouds.length && clouds[0].x < -100) clouds.shift(); 
      if(Math.random()<0.02) spawnCloud(); 
    }
    
    function drawClouds(){ 
      clouds.forEach(c=>{ 
        ctx.save();
        ctx.fillStyle = c.type === 'fluffy' ? 'rgba(255,255,255,0.9)' : 'rgba(219,234,254,0.8)';
        
        // 복잡한 구름 형태
        for(let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.arc(c.x + i*12*c.s - 12*c.s, c.y + Math.sin(i)*5, (15-i*2)*c.s, 0, Math.PI*2);
          ctx.fill();
        }
        
        if(c.type === 'fluffy') {
          ctx.fillStyle = 'rgba(255,255,255,0.7)';
          ctx.beginPath();
          ctx.arc(c.x, c.y - 8*c.s, 10*c.s, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      }); 
    }

    // 낮/밤 시스템
    let isNight=false, dayTimer=0; 
    const dayLength=20000;
    const stars = Array.from({length:60},()=>({
      x: rand(0,world.w), 
      y: rand(0,150), 
      r: rand(0.5,2),
      twinkle: rand(0, Math.PI*2)
    }));
    
    function drawSkyOverlay(){
      if(isNight){
        ctx.save();
        // 밤하늘 그라데이션
        const gradient = ctx.createLinearGradient(0, 0, 0, world.h);
        gradient.addColorStop(0, 'rgba(2,6,23,0.6)');
        gradient.addColorStop(1, 'rgba(2,6,23,0.3)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0,0,world.w,world.h);
        
        // 반짝이는 별
        for(const s of stars){ 
          ctx.fillStyle = `rgba(255,255,255,${0.5 + Math.sin(world.time/500 + s.twinkle)*0.5})`;
          ctx.beginPath(); 
          ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); 
          ctx.fill(); 
        }
        
        // 달
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.arc(world.w - 100, 50, 25, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'rgba(200,200,200,0.3)';
        ctx.beginPath();
        ctx.arc(world.w - 95, 45, 3, 0, Math.PI*2);
        ctx.arc(world.w - 105, 55, 5, 0, Math.PI*2);
        ctx.fill();
        
        ctx.restore();
      }
    }

    // 향상된 플레이어
    class Player{
      constructor(){ 
        this.x=66; this.y=world.groundY-48; this.w=46; this.h=48; 
        this.vy=0; this.g=0.85; this.jumpP=14.5; 
        this.onGround=true; this.ducking=false; this.alive=true;
        this.jumpsLeft = 2; // 더블점프
        this.rotation = 0;
        this.eyeBlink = 0;
      }
      
      rect(){ 
        const margin = this.ducking ? 4 : 2;
        return {x:this.x+margin,y:this.y+margin,w:this.w-margin*2,h:this.h-margin*2}; 
      }
      
      jump(){ 
        if(this.jumpsLeft > 0 && this.alive){ 
          this.vy = -this.jumpP; 
          this.jumpsLeft--;
          this.onGround = false; // 중요! 점프시 onGround를 false로 설정
          this.duck(false);
          spawnParticles(this.x + this.w/2, this.y + this.h, '#60a5fa', 8);
          
          // 더블점프 효과
          if(this.jumpsLeft === 0 && powerups.doubleJump <= 0) {
            this.rotation = Math.PI * 2;
          }
        }
      }
      
      duck(on=true){ 
        if(!this.alive) return; 
        this.ducking=on; 
        this.h = on? 30 : 48; 
        if(on) this.y = Math.min(this.y+18, world.groundY-this.h); 
      }
      
      update(){ 
        if(!this.onGround){ 
          this.y += this.vy; 
          this.vy += this.g;
          
          if(this.rotation > 0) {
            this.rotation -= 0.15;
            if(this.rotation < 0) this.rotation = 0;
          }
          
          if(this.y >= world.groundY - this.h){ 
            this.y = world.groundY - this.h; 
            this.vy=0; 
            this.onGround=true;
            this.jumpsLeft = powerups.doubleJump > 0 ? 3 : 2;
            this.rotation = 0;
            
            // 착지 파티클
            spawnParticles(this.x + this.w/2, world.groundY, '#94a3b8', 5);
          } 
        }
        // else 블록 제거 - 매 프레임마다 jumpsLeft를 리셋하지 않음
        
        // 눈 깜빡임
        if(Math.random() < 0.01) this.eyeBlink = 3;
        if(this.eyeBlink > 0) this.eyeBlink--;
      }
      
      draw(){
        const {x,y,w,h} = this.rect();
        ctx.save(); 
        
        // 무적 효과
        if(powerups.invincible > 0) {
          ctx.shadowColor = '#fbbf24';
          ctx.shadowBlur = 15;
          ctx.globalAlpha = 0.8 + Math.sin(world.time/50)*0.2;
        }
        
        ctx.translate(x + w/2, y + h/2);
        ctx.rotate(this.rotation);
        ctx.translate(-w/2, -h/2);
        
        // 공룡 몸통 (더 디테일하게)
        ctx.fillStyle = '#16a34a';
        ctx.fillRect(0, 0, w-6, h);
        
        // 배 부분
        ctx.fillStyle = '#86efac';
        ctx.fillRect(4, h*0.3, w-14, h*0.6);
        
        // 머리
        ctx.fillStyle = '#16a34a';
        ctx.fillRect(w - 20, -16, 24, 22);
        ctx.fillRect(w - 16, -18, 18, 2); // 머리 윗부분
        
        // 눈
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(w - 8, -12, 6, 6);
        ctx.fillStyle = '#000000';
        if(this.eyeBlink === 0) {
          ctx.fillRect(w - 6, -10, 3, 3); // 눈동자
        } else {
          ctx.fillRect(w - 8, -9, 6, 1); // 감은 눈
        }
        
        // 코
        ctx.fillStyle = '#059669';
        ctx.fillRect(w + 2, -8, 2, 2);
        
        // 입
        ctx.beginPath();
        ctx.moveTo(w - 2, -4);
        ctx.lineTo(w + 4, -4);
        ctx.lineTo(w + 4, -2);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // 꼬리 (더 역동적)
        ctx.fillStyle = '#16a34a';
        ctx.beginPath();
        ctx.moveTo(0, h*0.3);
        ctx.quadraticCurveTo(-18, h*0.4 + Math.sin(world.time/100)*3, -12, h*0.6);
        ctx.lineTo(0, h*0.7);
        ctx.closePath();
        ctx.fill();
        
        // 팔
        ctx.fillStyle = '#16a34a';
        const armSwing = Math.sin(world.time/80) * 2;
        ctx.fillRect(w*0.4, h*0.2 + armSwing, 6, 12);
        ctx.fillRect(w*0.6, h*0.2 - armSwing, 6, 12);
        
        // 다리 애니메이션 (더 부드럽게)
        const step = (world.time/100)%1;
        const leg1Y = h + Math.sin(step * Math.PI * 2) * 4;
        const leg2Y = h + Math.sin((step + 0.5) * Math.PI * 2) * 4;
        
        ctx.fillStyle = '#059669';
        ctx.fillRect(8, leg1Y, 10, 12);
        ctx.fillRect(28, leg2Y, 10, 12);
        
        // 발
        ctx.fillStyle = '#047857';
        ctx.fillRect(6, leg1Y + 10, 14, 4);
        ctx.fillRect(26, leg2Y + 10, 14, 4);
        
        ctx.restore();
      }
    }

    // 향상된 장애물
    class Obstacle{
      constructor(type='cactus'){
        this.type = type;
        this.passed = false;
        
        if(type==='cactus'){
          const sizes = ['small', 'medium', 'large', 'cluster'];
          this.size = sizes[Math.floor(Math.random()*sizes.length)];
          
          switch(this.size) {
            case 'small':
              this.w = 20; this.h = 40; break;
            case 'medium':
              this.w = 28; this.h = 55; break;
            case 'large':
              this.w = 36; this.h = 70; break;
            case 'cluster':
              this.w = 55; this.h = 50; break;
          }
          
          this.x = world.w + rand(10,50); 
          this.y = world.groundY - this.h;
          
        } else if(type==='bird') {
          this.w = 36; this.h = 28; 
          this.x = world.w + rand(10,50); 
          this.y = world.groundY - [70,100,140][Math.floor(Math.random()*3)];
          this.wingPhase = rand(0, Math.PI*2);
          
        } else if(type==='pterodactyl') {
          this.w = 48; this.h = 36;
          this.x = world.w + rand(10,50);
          this.y = world.groundY - rand(80,160);
          this.swoopPhase = 0;
        }
      }
      
      rect(){ return {x:this.x,y:this.y,w:this.w,h:this.h}; }
      
      update(){ 
        this.x -= speed;
        
        if(this.type === 'pterodactyl') {
          this.y += Math.sin(this.swoopPhase) * 2;
          this.swoopPhase += 0.1;
        }
      }
      
      draw(){ 
        ctx.save(); 
        
        if(this.type==='cactus'){
          // 선인장 그림자
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.ellipse(this.x + this.w/2, world.groundY + 5, this.w/2, 3, 0, 0, Math.PI*2);
          ctx.fill();
          
          // 선인장 본체
          const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
          gradient.addColorStop(0, '#22c55e');
          gradient.addColorStop(1, '#15803d');
          ctx.fillStyle = gradient;
          
          if(this.size === 'cluster') {
            // 여러 개 선인장
            ctx.fillRect(this.x, this.y + 10, 18, this.h - 10);
            ctx.fillRect(this.x + 20, this.y, 15, this.h);
            ctx.fillRect(this.x + 37, this.y + 15, 18, this.h - 15);
            
            // 가시
            ctx.fillStyle = '#14532d';
            for(let i = 0; i < 8; i++) {
              ctx.fillRect(this.x + 5 + (i%3)*18, this.y + 10 + i*6, 2, 4);
            }
          } else {
            ctx.fillRect(this.x, this.y, this.w, this.h);
            
            // 선인장 팔
            ctx.fillRect(this.x - 8, this.y + this.h*0.3, 8, 20);
            ctx.fillRect(this.x + this.w, this.y + this.h*0.25, 8, 25);
            
            // 가시 디테일
            ctx.fillStyle = '#14532d';
            for(let i = 0; i < 5; i++) {
              ctx.fillRect(this.x + 4 + i*5, this.y + 10 + i*8, 2, 4);
              ctx.fillRect(this.x + this.w - 6 - i*4, this.y + 15 + i*7, 2, 3);
            }
          }
          
          // 꽃 (가끔)
          if(this.size === 'large' && Math.random() > 0.7) {
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.arc(this.x + this.w/2, this.y - 5, 4, 0, Math.PI*2);
            ctx.fill();
          }
          
        } else if(this.type === 'bird') {
          // 새 그림자
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.ellipse(this.x + this.w/2, world.groundY + 5, this.w/3, 2, 0, 0, Math.PI*2);
          ctx.fill();
          
          // 새 몸통
          ctx.fillStyle = '#4b5563';
          ctx.fillRect(this.x + 4, this.y + this.h/2 - 5, this.w - 8, 10);
          
          // 머리
          ctx.beginPath();
          ctx.arc(this.x + this.w - 8, this.y + this.h/2, 6, 0, Math.PI*2);
          ctx.fill();
          
          // 부리
          ctx.fillStyle = '#fb923c';
          ctx.beginPath();
          ctx.moveTo(this.x + this.w, this.y + this.h/2);
          ctx.lineTo(this.x + this.w + 6, this.y + this.h/2);
          ctx.lineTo(this.x + this.w, this.y + this.h/2 + 3);
          ctx.closePath();
          ctx.fill();
          
          // 날개 애니메이션
          const wingFlap = Math.sin(world.time/60 + this.wingPhase) * 15;
          ctx.fillStyle = '#374151';
          ctx.beginPath();
          ctx.moveTo(this.x + 8, this.y + this.h/2);
          ctx.lineTo(this.x + 2, this.y + this.h/2 + wingFlap);
          ctx.lineTo(this.x + 14, this.y + this.h/2 + wingFlap/2);
          ctx.closePath();
          ctx.fill();
          
          ctx.beginPath();
          ctx.moveTo(this.x + this.w - 14, this.y + this.h/2);
          ctx.lineTo(this.x + this.w - 2, this.y + this.h/2 - wingFlap);
          ctx.lineTo(this.x + this.w - 8, this.y + this.h/2 - wingFlap/2);
          ctx.closePath();
          ctx.fill();
          
          // 눈
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(this.x + this.w - 6, this.y + this.h/2 - 2, 2, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.arc(this.x + this.w - 5, this.y + this.h/2 - 2, 1, 0, Math.PI*2);
          ctx.fill();
          
        } else if(this.type === 'pterodactyl') {
          // 익룡
          ctx.fillStyle = '#7c3aed';
          
          // 몸통
          ctx.beginPath();
          ctx.ellipse(this.x + this.w/2, this.y + this.h/2, 12, 8, 0, 0, Math.PI*2);
          ctx.fill();
          
          // 날개
          const wingSpan = Math.sin(world.time/70) * 5;
          ctx.beginPath();
          ctx.moveTo(this.x + this.w/2, this.y + this.h/2);
          ctx.lineTo(this.x - 10, this.y + this.h/2 + wingSpan);
          ctx.lineTo(this.x, this.y + this.h/2 + 10 + wingSpan);
          ctx.lineTo(this.x + this.w/2, this.y + this.h/2 + 5);
          ctx.closePath();
          ctx.fill();
          
          ctx.beginPath();
          ctx.moveTo(this.x + this.w/2, this.y + this.h/2);
          ctx.lineTo(this.x + this.w + 10, this.y + this.h/2 - wingSpan);
          ctx.lineTo(this.x + this.w, this.y + this.h/2 + 10 - wingSpan);
          ctx.lineTo(this.x + this.w/2, this.y + this.h/2 + 5);
          ctx.closePath();
          ctx.fill();
          
          // 머리
          ctx.fillStyle = '#6d28d9';
          ctx.beginPath();
          ctx.arc(this.x + this.w - 10, this.y + this.h/2 - 3, 5, 0, Math.PI*2);
          ctx.fill();
        }
        
        ctx.restore(); 
      }
    }

    // 수집 아이템
    class Collectible {
      constructor(type) {
        this.type = type;
        this.x = world.w + rand(50, 200);
        this.collected = false;
        this.rotation = 0;
        
        switch(type) {
          case 'coin':
            this.y = world.groundY - rand(50, 150);
            this.w = 20; this.h = 20;
            this.color = '#fbbf24';
            break;
          case 'powerup':
            this.y = world.groundY - rand(80, 120);
            this.w = 30; this.h = 30;
            this.subtype = ['invincible', 'doubleJump', 'magnet', 'slowmo'][Math.floor(Math.random()*4)];
            break;
        }
      }
      
      update() {
        this.x -= speed;
        this.rotation += 0.1;
        
        // 자석 효과
        if(powerups.magnet > 0 && this.type === 'coin') {
          const dx = (player.x + player.w/2) - (this.x + this.w/2);
          const dy = (player.y + player.h/2) - (this.y + this.h/2);
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          if(dist < 150) {
            this.x += dx * 0.1;
            this.y += dy * 0.1;
          }
        }
      }
      
      draw() {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        ctx.rotate(this.rotation);
        
        if(this.type === 'coin') {
          // 코인
          ctx.fillStyle = '#fbbf24';
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI*2);
          ctx.fill();
          
          ctx.fillStyle = '#f59e0b';
          ctx.beginPath();
          ctx.arc(0, 0, 7, 0, Math.PI*2);
          ctx.fill();
          
          ctx.fillStyle = '#fbbf24';
          ctx.font = 'bold 12px monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('$', 0, 0);
          
        } else if(this.type === 'powerup') {
          // 파워업
          const colors = {
            invincible: '#fbbf24',
            doubleJump: '#60a5fa',
            magnet: '#f472b6',
            slowmo: '#a78bfa'
          };
          
          ctx.fillStyle = colors[this.subtype];
          ctx.beginPath();
          
          // 별 모양
          for(let i = 0; i < 5; i++) {
            const angle = (Math.PI * 2 / 5) * i - Math.PI/2;
            const x = Math.cos(angle) * 15;
            const y = Math.sin(angle) * 15;
            if(i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
            
            const innerAngle = angle + Math.PI/5;
            const ix = Math.cos(innerAngle) * 7;
            const iy = Math.sin(innerAngle) * 7;
            ctx.lineTo(ix, iy);
          }
          ctx.closePath();
          ctx.fill();
          
          // 아이콘
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 10px monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const icons = {
            invincible: '⚡',
            doubleJump: '⬆',
            magnet: '🧲',
            slowmo: '⏱'
          };
          ctx.fillText(icons[this.subtype], 0, 0);
        }
        
        ctx.restore();
      }
    }

    // 게임 요소들
    const player = new Player();
    const obstacles=[];
    const collectibles = [];

    // 바닥 개선
    let groundOffset=0;
    const groundDetails = [];
    
    // 바닥 디테일 생성
    function generateGroundDetails() {
      groundDetails.length = 0;
      for(let i = 0; i < 30; i++) {
        groundDetails.push({
          x: rand(0, world.w),
          type: Math.random() > 0.7 ? 'grass' : 'stone',
          size: rand(0.5, 1.5)
        });
      }
    }
    
    function drawGround(){
      ctx.save();
      
      // 그라데이션 지면
      const gradient = ctx.createLinearGradient(0, world.groundY, 0, world.h);
      gradient.addColorStop(0, '#8b7355');
      gradient.addColorStop(0.3, '#6b5945');
      gradient.addColorStop(1, '#4a3f2f');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, world.groundY, world.w, world.h - world.groundY);
      
      // 지면 선
      ctx.strokeStyle = '#5c4a3a';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, world.groundY);
      ctx.lineTo(world.w, world.groundY);
      ctx.stroke();
      
      // 움직이는 디테일
      groundOffset = (groundOffset - speed) % 60;
      
      // 점선 트랙
      ctx.strokeStyle = '#7c6954';
      ctx.lineWidth = 2;
      ctx.setLineDash([30, 30]);
      ctx.beginPath();
      ctx.moveTo(groundOffset, world.groundY + 15);
      ctx.lineTo(world.w, world.groundY + 15);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // 바닥 디테일 (돌, 풀 등)
      for(const detail of groundDetails) {
        const x = (detail.x - world.time * speed * 0.1) % (world.w + 100);
        if(x < -50) detail.x = world.w + 50;
        
        if(detail.type === 'grass') {
          ctx.fillStyle = '#65a30d';
          for(let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(x + i*3*detail.size, world.groundY);
            ctx.lineTo(x + i*3*detail.size - 1, world.groundY - 5*detail.size);
            ctx.lineTo(x + i*3*detail.size + 1, world.groundY - 5*detail.size);
            ctx.closePath();
            ctx.fill();
          }
        } else {
          ctx.fillStyle = '#6b7280';
          ctx.beginPath();
          ctx.arc(x, world.groundY + 5, 2*detail.size, 0, Math.PI*2);
          ctx.fill();
        }
      }
      
      ctx.restore();
    }

    // 충돌 감지
    const collide=(a,b)=> a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;

    // 스폰 시스템 개선 - 시간에 따라 증가하는 난이도
    let spawnTimer = 0;
    let lastSpawnType = null;
    let difficultyMultiplier = 1;
    
    function spawnObstacle(){
      // 점수가 300 증가할 때마다 5% 더 자주 스폰
      difficultyMultiplier = 1 + Math.floor(score / 300) * 0.05;
      
      // 점수에 따른 장애물 타입 확률
      let types = [];
      if(score < 200) {
        types = ['cactus', 'cactus', 'cactus', 'bird'];
      } else if(score < 500) {
        types = ['cactus', 'cactus', 'bird', 'bird', 'pterodactyl'];
      } else {
        types = ['cactus', 'bird', 'bird', 'pterodactyl', 'pterodactyl'];
      }
      
      const type = types[Math.floor(Math.random() * types.length)];
      obstacles.push(new Obstacle(type));
      
      // 연속 스폰 (점수가 높을수록 확률 증가)
      const consecutiveChance = Math.min(0.4, 0.1 + score / 3000);
      if(Math.random() < consecutiveChance && score > 300) {
        setTimeout(() => {
          if(running && !gameOver) {
            obstacles.push(new Obstacle(type === 'cactus' ? 'bird' : 'cactus'));
          }
        }, 400 / difficultyMultiplier);
      }
      
      // 코인 스폰
      if(Math.random() < 0.4) {
        collectibles.push(new Collectible('coin'));
      }
      
      // 파워업 스폰
      if(Math.random() < 0.1 && score > 100) {
        collectibles.push(new Collectible('powerup'));
      }
    }

    function reset(){
      speed = 6.8; score = 0; world.time = 0; 
      groundOffset=0; obstacles.length=0; collectibles.length=0;
      combo = 0; maxCombo = 0; coins = 0;
      particles.length = 0;
      
      // 파워업 초기화
      for(let key in powerups) powerups[key] = 0;
      
      clouds.length=0; 
      for(let i=0;i<3;i++) spawnCloud();
      generateGroundDetails();
      
      player.x=66; player.y=world.groundY-48; 
      player.vy=0; player.h=48; 
      player.duck(false); 
      player.onGround=true; 
      player.alive=true;
      player.jumpsLeft = 2;
      player.rotation = 0;
      
      gameOver=false; paused=false; 
      isNight=false; dayTimer=0; 
      spawnTimer = 1000;
      difficultyMultiplier = 1;
      
      updateStats();
    }

    function update(dt){
      world.time += dt;
      
      if(!paused && running && !gameOver){
        // 슬로모션 효과
        const timeScale = powerups.slowmo > 0 ? 0.5 : 1;
        dt *= timeScale;
        
        // 배경
        updateClouds(dt);
        
        // 낮/밤
        dayTimer += dt;
        if(dayTimer >= dayLength){ 
          dayTimer = 0; 
          isNight = !isNight;
          
          // 낮밤 전환 파티클
          for(let i = 0; i < 20; i++) {
            particles.push(new Particle(
              rand(0, world.w),
              rand(0, world.h/2),
              isNight ? '#4338ca' : '#fbbf24',
              rand(2, 5)
            ));
          }
        }
        
        // 플레이어
        player.update();
        
        // 파워업 타이머
        for(let key in powerups) {
          if(powerups[key] > 0) {
            powerups[key] -= dt;
            if(powerups[key] <= 0) powerups[key] = 0;
          }
        }
        
        // 장애물 스폰
        spawnTimer -= dt * difficultyMultiplier;
        if(spawnTimer <= 0){
          spawnObstacle();
          const base = clamp(1400 - (speed-6.8)*100, 800, 1600);
          spawnTimer = base + rand(-200, 400);
        }
        
        // 장애물 업데이트
        for(const o of obstacles) o.update(dt);
        while(obstacles.length && obstacles[0].x + obstacles[0].w < -20) {
          const removed = obstacles.shift();
          
          // 장애물 통과 시
          if(!removed.passed && player.x > removed.x + removed.w) {
            removed.passed = true;
            combo++;
            if(combo > maxCombo) maxCombo = combo;
            
            // 콤보 파티클
            if(combo > 1) {
              spawnParticles(player.x + player.w/2, player.y, '#10b981', combo * 2);
            }
          }
        }
        
        // 수집품 업데이트
        for(let i = collectibles.length - 1; i >= 0; i--) {
          const c = collectibles[i];
          c.update();
          
          // 수집
          if(!c.collected && collide(player.rect(), {x:c.x, y:c.y, w:c.w, h:c.h})) {
            c.collected = true;
            
            if(c.type === 'coin') {
              coins++;
              totalCoins++;
              spawnParticles(c.x + c.w/2, c.y + c.h/2, '#fbbf24', 15);
            } else if(c.type === 'powerup') {
              powerups[c.subtype] = 5000; // 5초
              spawnParticles(c.x + c.w/2, c.y + c.h/2, '#8b5cf6', 20);
            }
            
            collectibles.splice(i, 1);
          } else if(c.x + c.w < -20) {
            collectibles.splice(i, 1);
          }
        }
        
        // 파티클 업데이트
        for(let i = particles.length - 1; i >= 0; i--) {
          if(!particles[i].update(dt)) {
            particles.splice(i, 1);
          }
        }
        
        // 점수/속도
        score += speed * 0.15;
        if(Math.floor(score) % 100 === 0) {
          speed = Math.min(16, speed + 0.02);
        }
        
        // 충돌 (무적 상태가 아닐 때만)
        if(powerups.invincible <= 0) {
          for(const o of obstacles){ 
            if(collide(player.rect(), o.rect())){ 
              gameOver=true; 
              running=false; 
              player.alive=false;
              combo = 0;
              
              // 게임오버 파티클
              spawnParticles(player.x + player.w/2, player.y + player.h/2, '#ef4444', 30);
              
              try{ 
                if(score>high){ 
                  high=Math.floor(score); 
                  localStorage.setItem('runnerHigh', high); 
                }
                localStorage.setItem('runnerCoins', totalCoins);
              }catch{} 
              break; 
            } 
          }
        }
        
        updateStats();
      }
    }

    function updateStats() {
      document.getElementById('combo').textContent = combo;
      document.getElementById('maxCombo').textContent = maxCombo;
      document.getElementById('coins').textContent = coins;
    }

    function drawHUD(){ 
      ctx.save(); 
      
      // 점수 배경
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(world.w - 180, 10, 170, 30);
      ctx.fillRect(10, 10, 170, 30);
      
      ctx.fillStyle = '#0f172a'; 
      ctx.font='bold 18px ui-monospace, monospace'; 
      const s = Math.floor(score).toString().padStart(5,'0'); 
      ctx.fillText(`🎯 ${s}`, world.w-160, 30); 
      
      ctx.fillStyle = '#64748b'; 
      ctx.fillText(`🏆 ${String(high).padStart(5,'0')}`, 20, 30); 
      
      // 파워업 표시
      let powerupY = 50;
      for(let key in powerups) {
        if(powerups[key] > 0) {
          const icons = {
            invincible: '⚡ 무적',
            doubleJump: '⬆ 더블점프',
            magnet: '🧲 자석',
            slowmo: '⏱ 슬로우'
          };
          
          ctx.fillStyle = 'rgba(139,92,246,0.9)';
          ctx.fillRect(world.w - 140, powerupY, 130, 25);
          
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 14px system-ui';
          ctx.fillText(icons[key], world.w - 130, powerupY + 17);
          
          // 타이머 바
          ctx.fillStyle = 'rgba(255,255,255,0.3)';
          ctx.fillRect(world.w - 50, powerupY + 8, 35, 8);
          ctx.fillStyle = '#fbbf24';
          ctx.fillRect(world.w - 50, powerupY + 8, 35 * (powerups[key]/5000), 8);
          
          powerupY += 30;
        }
      }
      
      // 콤보 표시
      if(combo > 1) {
        ctx.save();
        ctx.translate(world.w/2, 80);
        ctx.scale(1 + Math.sin(world.time/100)*0.1, 1 + Math.sin(world.time/100)*0.1);
        
        ctx.fillStyle = 'rgba(16,185,129,0.9)';
        ctx.fillRect(-50, -15, 100, 30);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 20px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(`${combo}x COMBO!`, 0, 5);
        ctx.restore();
      }
      
      ctx.restore(); 
    }

    function drawOverlay(){
      if(paused){ 
        overlayText('⏸️ 일시정지', '계속하려면 P 키를 누르세요');
      }
      else if(!running && !gameOver){ 
        overlayText('🦖 오프라인 러너', 'S 키 또는 [시작] 버튼으로 시작!');
      }
      else if(gameOver){ 
        overlayText('💀 GAME OVER', `최종 점수: ${Math.floor(score)} | 코인: ${coins} | 최고 콤보: ${maxCombo}`);
        subText('R 키 또는 [다시] 버튼으로 재시작');
      }
      
      function overlayText(title, subtitle){ 
        // 배경
        ctx.save(); 
        ctx.fillStyle='rgba(0,0,0,.75)'; 
        ctx.fillRect(0,0,world.w,world.h); 
        
        // 타이틀
        ctx.fillStyle='#ffffff'; 
        ctx.font='bold 36px system-ui'; 
        ctx.textAlign='center'; 
        ctx.fillText(title, world.w/2, world.h/2 - 20);
        
        // 서브타이틀
        ctx.font='600 18px system-ui';
        ctx.fillStyle='#cbd5e1';
        ctx.fillText(subtitle, world.w/2, world.h/2 + 15);
        
        ctx.restore(); 
      }
      
      function subText(t){ 
        ctx.save(); 
        ctx.fillStyle='#94a3b8'; 
        ctx.font='600 16px system-ui'; 
        ctx.textAlign='center'; 
        ctx.fillText(t, world.w/2, world.h/2 + 45); 
        ctx.restore(); 
      }
    }

    function render(){
      // 하늘 그라데이션
      const skyGradient = ctx.createLinearGradient(0, 0, 0, world.h);
      if(isNight) {
        skyGradient.addColorStop(0, '#1e293b');
        skyGradient.addColorStop(1, '#334155');
      } else {
        skyGradient.addColorStop(0, '#87ceeb');
        skyGradient.addColorStop(0.5, '#98d8e8');
        skyGradient.addColorStop(1, '#ffeaa7');
      }
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, world.w, world.h);
      
      drawMountains();
      drawClouds();
      drawSkyOverlay();
      drawGround();
      
      // 수집품
      for(const c of collectibles) if(!c.collected) c.draw();
      
      // 장애물
      for(const o of obstacles) o.draw();
      
      // 파티클
      for(const p of particles) p.draw();
      
      // 플레이어
      player.draw();
      
      drawHUD();
      drawOverlay();
    }

    // 게임 루프
    let last = performance.now();
    function loop(now){ 
      const dt = Math.min(40, now - last); 
      last = now; 
      
      if(running && !paused) update(dt); 
      render(); 
      
      requestAnimationFrame(loop); 
    }
    requestAnimationFrame(loop);

    // 입력 처리
    function handleKey(e,down){ 
      if(e.repeat) return; 
      const k=e.key.toLowerCase(); 
      
      if(down){ 
        if(k===' '||k==='arrowup') player.jump(); 
        if(k==='arrowdown') player.duck(true); 
        if(k==='r'){ reset(); running=true; } 
        if(k==='p' && running){ paused=!paused; } 
        if(k==='s'){ 
          if(gameOver) reset(); 
          running=true; 
        } 
      } else { 
        if(k==='arrowdown') player.duck(false); 
      } 
    }
    
    addEventListener('keydown', e=>handleKey(e,true)); 
    addEventListener('keyup', e=>handleKey(e,false));

    // 버튼 이벤트
    document.getElementById('startBtn').onclick=()=>{ 
      if(gameOver) reset(); 
      running=true; 
    };
    document.getElementById('restartBtn').onclick=()=>{ 
      reset(); 
      running=true; 
    };
    document.getElementById('pauseBtn').onclick=()=>{ 
      if(running) paused=!paused; 
    };
    
    // 모바일 버튼
    document.getElementById('jumpBtn').onclick=()=>player.jump();
    const duckBtn=document.getElementById('duckBtn'); 
    duckBtn.addEventListener('pointerdown',()=>player.duck(true)); 
    duckBtn.addEventListener('pointerup',()=>player.duck(false)); 
    duckBtn.addEventListener('pointerleave',()=>player.duck(false));

    // 포커스 관리
    addEventListener('blur', ()=>{ 
      if(running && !gameOver) paused=true; 
    });

    // 초기화
    reset();
    generateGroundDetails();
  })();
  </script>
</body>
</html>